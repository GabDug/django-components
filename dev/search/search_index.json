{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"django-components","text":"<p>Create simple reusable template components in Django</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\u2728 Reusable components: Create components that can be reused in different parts of your project, or even in different projects.</li> <li>\ud83d\udcc1 Single file components: Keep your Python, CSS, Javascript and HTML in one place (if you wish)</li> <li>\ud83c\udfb0 Slots: Define slots in your components to make them more flexible.</li> <li>\ud83d\udcbb CLI: A command line interface to help you create new components.</li> <li>\ud83d\ude80 Wide compatibility: Works with modern and LTS versions of Django.</li> <li>Load assets: Automatically load the right CSS and Javascript files for your components, with our middleware.</li> </ul>"},{"location":"#summary","title":"Summary","text":"<p>It lets you create \"template components\", that contains both the template, the Javascript and the CSS needed to generate the front end code you need for a modern app. Use components like this:</p> <pre><code>{% component \"calendar\" date=\"2015-06-19\" %}{% endcomponent %}\n</code></pre> <p>And this is what gets rendered (plus the CSS and Javascript you've specified):</p> <pre><code>&lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;2015-06-19&lt;/span&gt;&lt;/div&gt;\n</code></pre> <p>Read our user guide to set it up and learn about the details!</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p><code>django-components</code> is compatible with modern and LTS versions of Django.</p> <p>Check out the compatibility guide to see which versions are supported.</p>"},{"location":"#community-examples","title":"Community examples","text":"<p>One of our goals with <code>django-components</code> is to make it easy to share components between projects. If you have a set of components that you think would be useful to others, please open a pull request to add them to the list below.</p> <ul> <li>django-htmx-components: A set of components for use with htmx. Try out the live demo.</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>django-components</code> is licensed under the MIT license. See the LICENSE file for more details.</p>"},{"location":"CHANGELOG/","title":"Release notes","text":"<p>\ud83d\udea8\ud83d\udce2 Version 0.5 CHANGES THE SYNTAX for components.</p> <p><code>component_block</code> is now <code>component</code>, and <code>component</code> blocks need an ending <code>endcomponent</code> tag. The new <code>python manage.py upgradecomponent</code> command can be used to upgrade a directory (use --path argument to point to each dir) of components to the new syntax automatically.</p> <p>This change is done to simplify the API in anticipation of a 1.0 release of django_components. After 1.0 we intend to be stricter with big changes like this in point releases.</p> <p>Version 0.34 adds components as views, which allows you to handle requests and render responses from within a component. See the documentation for more details.</p> <p>Version 0.28 introduces 'implicit' slot filling and the <code>default</code> option for <code>slot</code> tags.</p> <p>Version 0.27 adds a second installable app: django_components.safer_staticfiles. It provides the same behavior as django.contrib.staticfiles but with extra security guarantees (more info below in Security Notes).</p> <p>Version 0.26 changes the syntax for <code>{% slot %}</code> tags. From now on, we separate defining a slot (<code>{% slot %}</code>) from filling a slot with content (<code>{% fill %}</code>). This means you will likely need to change a lot of slot tags to fill. We understand this is annoying, but it's the only way we can get support for nested slots that fill in other slots, which is a very nice featuPpre to have access to. Hoping that this will feel worth it!</p> <p>Version 0.22 starts autoimporting all files inside components subdirectores, to simplify setup. An existing project might start to get AlreadyRegistered-errors because of this. To solve this, either remove your custom loading of components, or set \"autodiscover\": False in settings.COMPONENTS.</p> <p>Version 0.17 renames <code>Component.context</code> and <code>Component.template</code> to <code>get_context_data</code> and <code>get_template_name</code>. The old methods still work, but emit a deprecation warning. This change was done to sync naming with Django's class based views, and make using django-components more familiar to Django users. <code>Component.context</code> and <code>Component.template</code> will be removed when version 1.0 is released.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or  advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic  address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a  professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at emil@emilstenstrom.se. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home<ul> <li>Changelog</li> <li>Code of Conduct</li> <li>License</li> </ul> </li> <li>Usage</li> <li>Developer Guide</li> <li>Reference<ul> <li>API Reference</li> </ul> </li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2019 Emil Stenstr\u00f6m</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"dev_guide/","title":"Development guide","text":""},{"location":"dev_guide/#running-django-components-project-locally","title":"Running django-components project locally","text":""},{"location":"dev_guide/#install-locally-and-run-the-tests","title":"Install locally and run the tests","text":"<p>Start by forking the project by clicking the Fork button up in the right corner in the GitHub . This makes a copy of the repository in your own name. Now you can clone this repository locally and start adding features:</p> <pre><code>git clone https://github.com/&lt;your GitHub username&gt;/django-components.git\n</code></pre> <p>To quickly run the tests install the local dependencies by running:</p> <pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>Now you can run the tests to make sure everything works as expected:</p> <pre><code>pytest\n</code></pre> <p>The library is also tested across many versions of Python and Django. To run tests that way:</p> <pre><code>pyenv install -s 3.8\npyenv install -s 3.9\npyenv install -s 3.10\npyenv install -s 3.11\npyenv install -s 3.12\npyenv local 3.8 3.9 3.10 3.11 3.12\ntox -p\n</code></pre>"},{"location":"dev_guide/#developing-against-live-django-app","title":"Developing against live Django app","text":"<p>How do you check that your changes to django-components project will work in an actual Django project?</p> <p>Use the sampleproject demo project to validate the changes:</p> <ol> <li> <p>Navigate to sampleproject directory:     <pre><code>cd sampleproject\n</code></pre></p> </li> <li> <p>Install dependencies from the requirements.txt file:     <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Link to your local version of django-components:     <pre><code>pip install -e ..\n</code></pre>     NOTE: The path (in this case <code>..</code>) must point to the directory that has the <code>setup.py</code> file.</p> </li> <li> <p>Start Django server     <pre><code>python manage.py runserver\n</code></pre></p> </li> </ol> <p>Once the server is up, it should be available at http://127.0.0.1:8000.</p> <p>To display individual components, add them to the <code>urls.py</code>, like in the case of http://127.0.0.1:8000/greeting</p>"},{"location":"dev_guide/#slot-rendering-flow","title":"Slot rendering flow","text":"<ol> <li> <p>Flow starts when a template string is being parsed into Django Template instance.</p> </li> <li> <p>When a <code>{% component %}</code> template tag is encountered, its body is searched for all <code>{% fill %}</code> nodes (explicit or implicit). and this is attached to the created <code>ComponentNode</code>.</p> <p>See the implementation of <code>component</code> template tag for details.</p> </li> <li> <p>Template rendering is a separate action from template parsing. When the template is being rendered, the <code>ComponentNode</code> creates an instance of the <code>Component</code> class and passes it the slot fills.</p> <p>It's at this point when <code>Component.render</code> is called, and the slots are   rendered.</p> </li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> django_components<ul> <li> app_settings</li> <li> apps</li> <li> component</li> <li> component_registry</li> <li> logger</li> <li> management<ul> <li> commands<ul> <li> startcomponent</li> <li> upgradecomponent</li> </ul> </li> </ul> </li> <li> middleware</li> <li> safer_staticfiles<ul> <li> apps</li> </ul> </li> <li> slots</li> <li> template_loader</li> <li> templatetags<ul> <li> component_tags</li> </ul> </li> <li> types</li> <li> utils</li> </ul> </li> </ul>"},{"location":"reference/django_components/","title":"Index","text":""},{"location":"reference/django_components/#django_components","title":"django_components","text":"<p>Main package for Django Components.</p>"},{"location":"reference/django_components/#django_components.component","title":"component","text":""},{"location":"reference/django_components/#django_components.component.Component","title":"Component","text":"<pre><code>Component(\n    registered_name: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]] = (),\n)\n</code></pre> <p>             Bases: <code>View</code></p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]] = (),  # type: ignore\n):\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.fill_content = fill_content\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.render","title":"render","text":"<pre><code>render(context_data: Dict[str, Any], slots_data: Optional[Dict[SlotName, str]] = None, escape_slots_content: bool = True) -&gt; str\n</code></pre> <p>Render the component and return the rendered HTML.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render(\n    self,\n    context_data: Dict[str, Any],\n    slots_data: Optional[Dict[SlotName, str]] = None,\n    escape_slots_content: bool = True,\n) -&gt; str:\n    \"\"\"Render the component and return the rendered HTML.\"\"\"\n    # NOTE: This if/else is important to avoid nested Contexts,\n    # See https://github.com/EmilStenstrom/django-components/issues/414\n    context = context_data if isinstance(context_data, Context) else Context(context_data)\n    template = self.get_template(context)\n\n    if slots_data:\n        self._fill_slots(slots_data, escape_slots_content)\n\n    return render_component_template_with_slots(template, context, self.fill_content, self.registered_name)\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.render_css_dependencies","title":"render_css_dependencies","text":"<pre><code>render_css_dependencies() -&gt; SafeString\n</code></pre> <p>Render only CSS dependencies available in the media class or provided as a string.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_css_dependencies(self) -&gt; SafeString:\n    \"\"\"Render only CSS dependencies available in the media class or provided as a string.\"\"\"\n    if self.css is not None:\n        return mark_safe(f\"&lt;style&gt;{self.css}&lt;/style&gt;\")\n    return mark_safe(\"\\n\".join(self.media.render_css()))\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.render_dependencies","title":"render_dependencies","text":"<pre><code>render_dependencies() -&gt; SafeString\n</code></pre> <p>Helper function to render all dependencies for a component.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_dependencies(self) -&gt; SafeString:\n    \"\"\"Helper function to render all dependencies for a component.\"\"\"\n    dependencies = []\n\n    css_deps = self.render_css_dependencies()\n    if css_deps:\n        dependencies.append(css_deps)\n\n    js_deps = self.render_js_dependencies()\n    if js_deps:\n        dependencies.append(js_deps)\n\n    return mark_safe(\"\\n\".join(dependencies))\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.render_js_dependencies","title":"render_js_dependencies","text":"<pre><code>render_js_dependencies() -&gt; SafeString\n</code></pre> <p>Render only JS dependencies available in the media class or provided as a string.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_js_dependencies(self) -&gt; SafeString:\n    \"\"\"Render only JS dependencies available in the media class or provided as a string.\"\"\"\n    if self.js is not None:\n        return mark_safe(f\"&lt;script&gt;{self.js}&lt;/script&gt;\")\n    return mark_safe(\"\\n\".join(self.media.render_js()))\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.render_to_response","title":"render_to_response","text":"<pre><code>render_to_response(\n    context_data: Dict[str, Any],\n    slots_data: Optional[Dict[SlotName, str]] = None,\n    escape_slots_content: bool = True,\n    *args: Any,\n    **kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and return an HttpResponse.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_to_response(\n    self,\n    context_data: Dict[str, Any],\n    slots_data: Optional[Dict[SlotName, str]] = None,\n    escape_slots_content: bool = True,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"Render the component and return an HttpResponse.\"\"\"\n    return HttpResponse(\n        self.render(context_data, slots_data, escape_slots_content),\n        *args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/django_components/#django_components.component.ComponentNode","title":"ComponentNode","text":"<pre><code>ComponentNode(\n    name_fexp: FilterExpression,\n    context_args: List[FilterExpression],\n    context_kwargs: Mapping[str, FilterExpression],\n    isolated_context: bool = False,\n    fill_nodes: Union[ImplicitFillNode, Iterable[NamedFillNode]] = (),\n)\n</code></pre> <p>             Bases: <code>Node</code></p> <p>Django.template.Node subclass that renders a django-components component</p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    name_fexp: FilterExpression,\n    context_args: List[FilterExpression],\n    context_kwargs: Mapping[str, FilterExpression],\n    isolated_context: bool = False,\n    fill_nodes: Union[ImplicitFillNode, Iterable[NamedFillNode]] = (),\n) -&gt; None:\n    self.name_fexp = name_fexp\n    self.context_args = context_args or []\n    self.context_kwargs = context_kwargs or {}\n    self.isolated_context = isolated_context\n    self.fill_nodes = fill_nodes\n    self.nodelist = self._create_nodelist(fill_nodes)\n</code></pre>"},{"location":"reference/django_components/#django_components.component.safe_resolve","title":"safe_resolve","text":"<pre><code>safe_resolve(context_item: FilterExpression, context: Context) -&gt; Any\n</code></pre> <p>Resolve FilterExpressions and Variables in context if possible.  Return other items unchanged.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def safe_resolve(context_item: FilterExpression, context: Context) -&gt; Any:\n    \"\"\"Resolve FilterExpressions and Variables in context if possible.  Return other items unchanged.\"\"\"\n\n    return context_item.resolve(context) if hasattr(context_item, \"resolve\") else context_item\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry","title":"component_registry","text":""},{"location":"reference/django_components/#django_components.component_registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry: ComponentRegistry = ComponentRegistry()\n</code></pre> <p>Global component registry.</p>"},{"location":"reference/django_components/#django_components.component_registry.register","title":"register","text":"<pre><code>register(name: str) -&gt; Callable[[_TC], _TC]\n</code></pre> <p>Class decorator to register a component.</p> Usage <pre><code>    @register(\"my_component\")\n    class MyComponent(component.Component):\n        ...\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(name: str) -&gt; Callable[[_TC], _TC]:\n    \"\"\"Class decorator to register a component.\n\n    Usage:\n        ```python\n            @register(\"my_component\")\n            class MyComponent(component.Component):\n                ...\n        ```\n    \"\"\"\n\n    def decorator(component: _TC) -&gt; _TC:\n        registry.register(name=name, component=component)\n        return component\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/#django_components.middleware","title":"middleware","text":""},{"location":"reference/django_components/#django_components.middleware.ComponentDependencyMiddleware","title":"ComponentDependencyMiddleware","text":"<pre><code>ComponentDependencyMiddleware(get_response: Callable[[HttpRequest], HttpResponse])\n</code></pre> <p>Middleware that inserts CSS/JS dependencies for all rendered components at points marked with template tags.</p> Source code in <code>src/django_components/middleware.py</code> <pre><code>def __init__(self, get_response: \"Callable[[HttpRequest], HttpResponse]\") -&gt; None:\n    self.get_response = get_response\n</code></pre>"},{"location":"reference/django_components/#django_components.middleware.DependencyReplacer","title":"DependencyReplacer","text":"<pre><code>DependencyReplacer(css_string: bytes, js_string: bytes)\n</code></pre> <p>Replacer for use in re.sub that replaces the first placeholder CSS and JS tags it encounters and removes any subsequent ones.</p> Source code in <code>src/django_components/middleware.py</code> <pre><code>def __init__(self, css_string: bytes, js_string: bytes) -&gt; None:\n    self.js_string = js_string\n    self.css_string = css_string\n</code></pre>"},{"location":"reference/django_components/#django_components.middleware.join_media","title":"join_media","text":"<pre><code>join_media(components: Iterable[Component]) -&gt; Media\n</code></pre> <p>Return combined media object for iterable of components.</p> Source code in <code>src/django_components/middleware.py</code> <pre><code>def join_media(components: Iterable[\"Component\"]) -&gt; Media:\n    \"\"\"Return combined media object for iterable of components.\"\"\"\n\n    return sum([component.media for component in components], Media())\n</code></pre>"},{"location":"reference/django_components/#django_components.safer_staticfiles","title":"safer_staticfiles","text":""},{"location":"reference/django_components/#django_components.safer_staticfiles.apps","title":"apps","text":""},{"location":"reference/django_components/#django_components.safer_staticfiles.apps.SaferStaticFilesConfig","title":"SaferStaticFilesConfig","text":"<p>             Bases: <code>StaticFilesConfig</code></p> <p>Extend the <code>ignore_patterns</code> class attr of StaticFilesConfig to include Python modules and HTML files.</p> <p>When this class is registered as an installed app, <code>$ ./manage.py collectstatic</code> will ignore .py and .html files, preventing potentially sensitive backend logic from being leaked by the static file server.</p>"},{"location":"reference/django_components/#django_components.slots","title":"slots","text":""},{"location":"reference/django_components/#django_components.slots.ImplicitFillNode","title":"ImplicitFillNode","text":"<pre><code>ImplicitFillNode(nodelist: NodeList)\n</code></pre> <p>             Bases: <code>BaseFillNode</code></p> <p>Instantiated when a <code>component</code> tag pair is passed template content that excludes <code>fill</code> tags. Nodes of this type contribute their nodelists to slots marked as 'default'.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, nodelist: NodeList):\n    self.nodelist: NodeList = nodelist\n</code></pre>"},{"location":"reference/django_components/#django_components.slots.UserSlotVar","title":"UserSlotVar","text":"<pre><code>UserSlotVar(slot: SlotNode, context: Context)\n</code></pre> <p>Extensible mechanism for offering 'fill' blocks in template access to properties of parent slot.</p> <p>How it works: At render time, SlotNode(s) that have been aliased in the fill tag of the component instance create an instance of UserSlotVar. This instance is made available to the rendering context on a key matching the slot alias (see SlotNode.render() for implementation).</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, slot: \"SlotNode\", context: Context):\n    self._slot = slot\n    self._context = context\n</code></pre>"},{"location":"reference/django_components/#django_components.slots.parse_slot_fill_nodes_from_component_nodelist","title":"parse_slot_fill_nodes_from_component_nodelist","text":"<pre><code>parse_slot_fill_nodes_from_component_nodelist(\n    component_nodelist: NodeList, ComponentNodeCls: Type[Node]\n) -&gt; Union[Iterable[NamedFillNode], ImplicitFillNode]\n</code></pre> <p>Given a component body (<code>django.template.NodeList</code>), find all slot fills, whether defined explicitly with <code>{% fill %}</code> or implicitly.</p> <p>So if we have a component body: <pre><code>{% component \"mycomponent\" %}\n    {% fill \"first_fill\" %}\n        Hello!\n    {% endfill %}\n    {% fill \"second_fill\" %}\n        Hello too!\n    {% endfill %}\n{% endcomponent %}\n</code></pre> Then this function returns the nodes (<code>django.template.Node</code>) for <code>fill \"first_fill\"</code> and <code>fill \"second_fill\"</code>.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def parse_slot_fill_nodes_from_component_nodelist(\n    component_nodelist: NodeList,\n    ComponentNodeCls: Type[Node],\n) -&gt; Union[Iterable[NamedFillNode], ImplicitFillNode]:\n    \"\"\"\n    Given a component body (`django.template.NodeList`), find all slot fills,\n    whether defined explicitly with `{% fill %}` or implicitly.\n\n    So if we have a component body:\n    ```django\n    {% component \"mycomponent\" %}\n        {% fill \"first_fill\" %}\n            Hello!\n        {% endfill %}\n        {% fill \"second_fill\" %}\n            Hello too!\n        {% endfill %}\n    {% endcomponent %}\n    ```\n    Then this function returns the nodes (`django.template.Node`) for `fill \"first_fill\"`\n    and `fill \"second_fill\"`.\n    \"\"\"\n    fill_nodes: Union[Iterable[NamedFillNode], ImplicitFillNode] = []\n    if _block_has_content(component_nodelist):\n        for parse_fn in (\n            _try_parse_as_default_fill,\n            _try_parse_as_named_fill_tag_set,\n        ):\n            curr_fill_nodes = parse_fn(component_nodelist, ComponentNodeCls)\n            if curr_fill_nodes:\n                fill_nodes = curr_fill_nodes\n                break\n        else:\n            raise TemplateSyntaxError(\n                \"Illegal content passed to 'component' tag pair. \"\n                \"Possible causes: 1) Explicit 'fill' tags cannot occur alongside other \"\n                \"tags except comment tags; 2) Default (default slot-targeting) content \"\n                \"is mixed with explict 'fill' tags.\"\n            )\n    return fill_nodes\n</code></pre>"},{"location":"reference/django_components/#django_components.slots.render_component_template_with_slots","title":"render_component_template_with_slots","text":"<pre><code>render_component_template_with_slots(\n    template: Template,\n    context: Context,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]],\n    registered_name: Optional[str],\n) -&gt; str\n</code></pre> <p>Given a template, context, and slot fills, this function first prepares the template to be able to render the fills in the place of slots, and then renders the template with given context.</p> <p>NOTE: The template is mutated in the process!</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def render_component_template_with_slots(\n    template: Template,\n    context: Context,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]],\n    registered_name: Optional[str],\n) -&gt; str:\n    \"\"\"\n    Given a template, context, and slot fills, this function first prepares\n    the template to be able to render the fills in the place of slots, and then\n    renders the template with given context.\n\n    NOTE: The template is mutated in the process!\n    \"\"\"\n    prev_filled_slots_context: Optional[FilledSlotsContext] = context.get(FILLED_SLOTS_CONTENT_CONTEXT_KEY)\n    updated_filled_slots_context = _prepare_component_template_filled_slot_context(\n        template,\n        fill_content,\n        prev_filled_slots_context,\n        registered_name,\n    )\n    with context.update({FILLED_SLOTS_CONTENT_CONTEXT_KEY: updated_filled_slots_context}):\n        return template.render(context)\n</code></pre>"},{"location":"reference/django_components/#django_components.template_loader","title":"template_loader","text":"<p>Template loader that loads templates from each Django app's \"components\" directory.</p>"},{"location":"reference/django_components/#django_components.templatetags","title":"templatetags","text":""},{"location":"reference/django_components/#django_components.templatetags.component_tags","title":"component_tags","text":""},{"location":"reference/django_components/#django_components.templatetags.component_tags.check_for_isolated_context_keyword","title":"check_for_isolated_context_keyword","text":"<pre><code>check_for_isolated_context_keyword(bits: List[str]) -&gt; Tuple[List[str], bool]\n</code></pre> <p>Return True and strip the last word if token ends with 'only' keyword or if CONTEXT_BEHAVIOR is 'isolated'.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def check_for_isolated_context_keyword(bits: List[str]) -&gt; Tuple[List[str], bool]:\n    \"\"\"Return True and strip the last word if token ends with 'only' keyword or if CONTEXT_BEHAVIOR is 'isolated'.\"\"\"\n\n    if bits[-1] == \"only\":\n        return bits[:-1], True\n\n    if app_settings.CONTEXT_BEHAVIOR == \"isolated\":\n        return bits, True\n\n    return bits, False\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component_css_dependencies_tag","title":"component_css_dependencies_tag","text":"<pre><code>component_css_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where CSS link tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_css_dependencies\")\ndef component_css_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where CSS link tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + CSS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_css_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component_dependencies_tag","title":"component_dependencies_tag","text":"<pre><code>component_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where CSS link and JS script tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_dependencies\")\ndef component_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where CSS link and JS script tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + CSS_DEPENDENCY_PLACEHOLDER + JS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component_js_dependencies_tag","title":"component_js_dependencies_tag","text":"<pre><code>component_js_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where JS script tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_js_dependencies\")\ndef component_js_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where JS script tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + JS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_js_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.do_component","title":"do_component","text":"<pre><code>do_component(parser: Parser, token: Token) -&gt; ComponentNode\n</code></pre> To give the component access to the template context <p><code>{% component \"name\" positional_arg keyword_arg=value ... %}</code></p> To render the component in an isolated context <p><code>{% component \"name\" positional_arg keyword_arg=value ... only %}</code></p> <p>Positional and keyword arguments can be literals or template variables. The component name must be a single- or double-quotes string and must be either the first positional argument or, if there are no positional arguments, passed as 'name'.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"component\")\ndef do_component(parser: Parser, token: Token) -&gt; ComponentNode:\n    \"\"\"\n    To give the component access to the template context:\n        ```#!htmldjango {% component \"name\" positional_arg keyword_arg=value ... %}```\n\n    To render the component in an isolated context:\n        ```#!htmldjango {% component \"name\" positional_arg keyword_arg=value ... only %}```\n\n    Positional and keyword arguments can be literals or template variables.\n    The component name must be a single- or double-quotes string and must\n    be either the first positional argument or, if there are no positional\n    arguments, passed as 'name'.\n    \"\"\"\n\n    bits = token.split_contents()\n    bits, isolated_context = check_for_isolated_context_keyword(bits)\n    component_name, context_args, context_kwargs = parse_component_with_args(parser, bits, \"component\")\n    body: NodeList = parser.parse(parse_until=[\"endcomponent\"])\n    parser.delete_first_token()\n    fill_nodes = parse_slot_fill_nodes_from_component_nodelist(body, ComponentNode)\n    component_node = ComponentNode(\n        FilterExpression(component_name, parser),\n        context_args,\n        context_kwargs,\n        isolated_context=isolated_context,\n        fill_nodes=fill_nodes,\n    )\n\n    return component_node\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.do_fill","title":"do_fill","text":"<pre><code>do_fill(parser: Parser, token: Token) -&gt; NamedFillNode\n</code></pre> <p>Block tag whose contents 'fill' (are inserted into) an identically named 'slot'-block in the component template referred to by a parent component. It exists to make component nesting easier.</p> <p>This tag is available only within a {% component %}..{% endcomponent %} block. Runtime checks should prohibit other usages.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"fill\")\ndef do_fill(parser: Parser, token: Token) -&gt; NamedFillNode:\n    \"\"\"Block tag whose contents 'fill' (are inserted into) an identically named\n    'slot'-block in the component template referred to by a parent component.\n    It exists to make component nesting easier.\n\n    This tag is available only within a {% component %}..{% endcomponent %} block.\n    Runtime checks should prohibit other usages.\n    \"\"\"\n    bits = token.split_contents()\n    tag = bits[0]\n    args = bits[1:]\n    # e.g. {% fill &lt;name&gt; %}\n    alias_fexp: Optional[FilterExpression] = None\n    if len(args) == 1:\n        tgt_slot_name: str = args[0]\n    # e.g. {% fill &lt;name&gt; as &lt;alias&gt; %}\n    elif len(args) == 3:\n        tgt_slot_name, as_keyword, alias = args\n        if as_keyword.lower() != \"as\":\n            raise TemplateSyntaxError(f\"{tag} tag args do not conform to pattern '&lt;target slot&gt; as &lt;alias&gt;'\")\n        alias_fexp = FilterExpression(alias, parser)\n    else:\n        raise TemplateSyntaxError(f\"'{tag}' tag takes either 1 or 3 arguments: Received {len(args)}.\")\n    nodelist = parser.parse(parse_until=[\"endfill\"])\n    parser.delete_first_token()\n\n    return NamedFillNode(\n        nodelist,\n        name_fexp=FilterExpression(tgt_slot_name, tag),\n        alias_fexp=alias_fexp,\n    )\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.do_if_filled_block","title":"do_if_filled_block","text":"<pre><code>do_if_filled_block(parser: Parser, token: Token) -&gt; IfSlotFilledNode\n</code></pre> Example <pre><code>{% if_filled &lt;slot&gt; (&lt;bool&gt;) %}\n    ...\n{% elif_filled &lt;slot&gt; (&lt;bool&gt;) %}\n    ...\n{% else_filled %}\n    ...\n{% endif_filled %}\n</code></pre> Notes <p>Optional arg <code>&lt;bool&gt;</code> is True by default. If a False is provided instead, the effect is a negation of the <code>if_filled</code> check: The behavior is analogous to <code>if not is_filled &lt;slot&gt;</code>. This design prevents us having to define a separate <code>if_unfilled</code> tag.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"if_filled\")\ndef do_if_filled_block(parser: Parser, token: Token) -&gt; \"IfSlotFilledNode\":\n    \"\"\"\n    Example:\n        ```htmldjango\n        {% if_filled &lt;slot&gt; (&lt;bool&gt;) %}\n            ...\n        {% elif_filled &lt;slot&gt; (&lt;bool&gt;) %}\n            ...\n        {% else_filled %}\n            ...\n        {% endif_filled %}\n        ```\n\n    Notes:\n        Optional arg `&lt;bool&gt;` is True by default.\n        If a False is provided instead, the effect is a negation of the `if_filled` check:\n        The behavior is analogous to `if not is_filled &lt;slot&gt;`.\n        This design prevents us having to define a separate `if_unfilled` tag.\n    \"\"\"\n    bits = token.split_contents()\n    starting_tag = bits[0]\n    slot_name, is_positive = parse_if_filled_bits(bits)\n    nodelist: NodeList = parser.parse((\"elif_filled\", \"else_filled\", \"endif_filled\"))\n    branches: List[_IfSlotFilledBranchNode] = [\n        IfSlotFilledConditionBranchNode(\n            slot_name=slot_name,  # type: ignore\n            nodelist=nodelist,\n            is_positive=is_positive,\n        )\n    ]\n\n    token = parser.next_token()\n\n    # {% elif_filled &lt;slot&gt; (&lt;is_positive&gt;) %} (repeatable)\n    while token.contents.startswith(\"elif_filled\"):\n        bits = token.split_contents()\n        slot_name, is_positive = parse_if_filled_bits(bits)\n        nodelist = parser.parse((\"elif_filled\", \"else_filled\", \"endif_filled\"))\n        branches.append(\n            IfSlotFilledConditionBranchNode(\n                slot_name=slot_name,  # type: ignore\n                nodelist=nodelist,\n                is_positive=is_positive,\n            )\n        )\n\n        token = parser.next_token()\n\n    # {% else_filled %} (optional)\n    if token.contents.startswith(\"else_filled\"):\n        bits = token.split_contents()\n        _, _ = parse_if_filled_bits(bits)\n        nodelist = parser.parse((\"endif_filled\",))\n        branches.append(IfSlotFilledElseBranchNode(nodelist))\n        token = parser.next_token()\n\n    # {% endif_filled %}\n    if token.contents != \"endif_filled\":\n        raise TemplateSyntaxError(\n            f\"{{% {starting_tag} %}} missing closing {{% endif_filled %}} tag\"\n            f\" at line {token.lineno}: '{token.contents}'\"\n        )\n\n    return IfSlotFilledNode(branches)\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.get_components_from_preload_str","title":"get_components_from_preload_str","text":"<pre><code>get_components_from_preload_str(preload_str: str) -&gt; List[Component]\n</code></pre> <p>Returns a list of unique components from a comma-separated str</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def get_components_from_preload_str(preload_str: str) -&gt; List[\"Component\"]:\n    \"\"\"Returns a list of unique components from a comma-separated str\"\"\"\n\n    components = []\n    for component_name in preload_str.split(\",\"):\n        component_name = component_name.strip()\n        if not component_name:\n            continue\n        component_class = component_registry.get(component_name)\n        components.append(component_class(component_name))\n\n    return components\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.get_components_from_registry","title":"get_components_from_registry","text":"<pre><code>get_components_from_registry(registry: ComponentRegistry) -&gt; List[Component]\n</code></pre> <p>Returns a list unique components from the registry.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def get_components_from_registry(registry: ComponentRegistry) -&gt; List[\"Component\"]:\n    \"\"\"Returns a list unique components from the registry.\"\"\"\n\n    unique_component_classes = set(registry.all().values())\n\n    components = []\n    for component_class in unique_component_classes:\n        components.append(component_class(component_class.__name__))\n\n    return components\n</code></pre>"},{"location":"reference/django_components/#django_components.types","title":"types","text":"<p>Helper types for IDEs.</p>"},{"location":"reference/django_components/#django_components.utils","title":"utils","text":""},{"location":"reference/django_components/#django_components.utils.search","title":"search","text":"<pre><code>search(search_glob: Optional[str] = None, engine: Optional[Engine] = None) -&gt; Union[List[str], List[Path]]\n</code></pre> <p>Search for directories that may contain components.</p> <p>If <code>search_glob</code> is given, the directories are searched for said glob pattern, and glob search results are returned as a flattened list.</p> Source code in <code>src/django_components/utils.py</code> <pre><code>def search(search_glob: Optional[str] = None, engine: Optional[Engine] = None) -&gt; Union[List[str], List[Path]]:\n    \"\"\"\n    Search for directories that may contain components.\n\n    If `search_glob` is given, the directories are searched for said glob pattern,\n    and glob search results are returned as a flattened list.\n    \"\"\"\n    current_engine = engine\n    if current_engine is None:\n        current_engine = Engine.get_default()\n\n    loader = Loader(current_engine)\n    dirs = loader.get_dirs()\n\n    if search_glob is None:\n        return dirs\n\n    component_filenames: List[str] = []\n    for directory in dirs:\n        for path in glob.iglob(str(Path(directory) / search_glob), recursive=True):\n            component_filenames.append(path)\n\n    return component_filenames\n</code></pre>"},{"location":"reference/django_components/app_settings/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> app_settings","text":""},{"location":"reference/django_components/app_settings/#django_components.app_settings","title":"app_settings","text":""},{"location":"reference/django_components/apps/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> apps","text":""},{"location":"reference/django_components/apps/#django_components.apps","title":"apps","text":""},{"location":"reference/django_components/component/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> component","text":""},{"location":"reference/django_components/component/#django_components.component","title":"component","text":""},{"location":"reference/django_components/component/#django_components.component.Component","title":"Component","text":"<pre><code>Component(\n    registered_name: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]] = (),\n)\n</code></pre> <p>             Bases: <code>View</code></p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]] = (),  # type: ignore\n):\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.fill_content = fill_content\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.render","title":"render","text":"<pre><code>render(context_data: Dict[str, Any], slots_data: Optional[Dict[SlotName, str]] = None, escape_slots_content: bool = True) -&gt; str\n</code></pre> <p>Render the component and return the rendered HTML.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render(\n    self,\n    context_data: Dict[str, Any],\n    slots_data: Optional[Dict[SlotName, str]] = None,\n    escape_slots_content: bool = True,\n) -&gt; str:\n    \"\"\"Render the component and return the rendered HTML.\"\"\"\n    # NOTE: This if/else is important to avoid nested Contexts,\n    # See https://github.com/EmilStenstrom/django-components/issues/414\n    context = context_data if isinstance(context_data, Context) else Context(context_data)\n    template = self.get_template(context)\n\n    if slots_data:\n        self._fill_slots(slots_data, escape_slots_content)\n\n    return render_component_template_with_slots(template, context, self.fill_content, self.registered_name)\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.render_css_dependencies","title":"render_css_dependencies","text":"<pre><code>render_css_dependencies() -&gt; SafeString\n</code></pre> <p>Render only CSS dependencies available in the media class or provided as a string.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_css_dependencies(self) -&gt; SafeString:\n    \"\"\"Render only CSS dependencies available in the media class or provided as a string.\"\"\"\n    if self.css is not None:\n        return mark_safe(f\"&lt;style&gt;{self.css}&lt;/style&gt;\")\n    return mark_safe(\"\\n\".join(self.media.render_css()))\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.render_dependencies","title":"render_dependencies","text":"<pre><code>render_dependencies() -&gt; SafeString\n</code></pre> <p>Helper function to render all dependencies for a component.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_dependencies(self) -&gt; SafeString:\n    \"\"\"Helper function to render all dependencies for a component.\"\"\"\n    dependencies = []\n\n    css_deps = self.render_css_dependencies()\n    if css_deps:\n        dependencies.append(css_deps)\n\n    js_deps = self.render_js_dependencies()\n    if js_deps:\n        dependencies.append(js_deps)\n\n    return mark_safe(\"\\n\".join(dependencies))\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.render_js_dependencies","title":"render_js_dependencies","text":"<pre><code>render_js_dependencies() -&gt; SafeString\n</code></pre> <p>Render only JS dependencies available in the media class or provided as a string.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_js_dependencies(self) -&gt; SafeString:\n    \"\"\"Render only JS dependencies available in the media class or provided as a string.\"\"\"\n    if self.js is not None:\n        return mark_safe(f\"&lt;script&gt;{self.js}&lt;/script&gt;\")\n    return mark_safe(\"\\n\".join(self.media.render_js()))\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.render_to_response","title":"render_to_response","text":"<pre><code>render_to_response(\n    context_data: Dict[str, Any],\n    slots_data: Optional[Dict[SlotName, str]] = None,\n    escape_slots_content: bool = True,\n    *args: Any,\n    **kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and return an HttpResponse.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def render_to_response(\n    self,\n    context_data: Dict[str, Any],\n    slots_data: Optional[Dict[SlotName, str]] = None,\n    escape_slots_content: bool = True,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"Render the component and return an HttpResponse.\"\"\"\n    return HttpResponse(\n        self.render(context_data, slots_data, escape_slots_content),\n        *args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.ComponentNode","title":"ComponentNode","text":"<pre><code>ComponentNode(\n    name_fexp: FilterExpression,\n    context_args: List[FilterExpression],\n    context_kwargs: Mapping[str, FilterExpression],\n    isolated_context: bool = False,\n    fill_nodes: Union[ImplicitFillNode, Iterable[NamedFillNode]] = (),\n)\n</code></pre> <p>             Bases: <code>Node</code></p> <p>Django.template.Node subclass that renders a django-components component</p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    name_fexp: FilterExpression,\n    context_args: List[FilterExpression],\n    context_kwargs: Mapping[str, FilterExpression],\n    isolated_context: bool = False,\n    fill_nodes: Union[ImplicitFillNode, Iterable[NamedFillNode]] = (),\n) -&gt; None:\n    self.name_fexp = name_fexp\n    self.context_args = context_args or []\n    self.context_kwargs = context_kwargs or {}\n    self.isolated_context = isolated_context\n    self.fill_nodes = fill_nodes\n    self.nodelist = self._create_nodelist(fill_nodes)\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.safe_resolve","title":"safe_resolve","text":"<pre><code>safe_resolve(context_item: FilterExpression, context: Context) -&gt; Any\n</code></pre> <p>Resolve FilterExpressions and Variables in context if possible.  Return other items unchanged.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def safe_resolve(context_item: FilterExpression, context: Context) -&gt; Any:\n    \"\"\"Resolve FilterExpressions and Variables in context if possible.  Return other items unchanged.\"\"\"\n\n    return context_item.resolve(context) if hasattr(context_item, \"resolve\") else context_item\n</code></pre>"},{"location":"reference/django_components/component_registry/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> component_registry","text":""},{"location":"reference/django_components/component_registry/#django_components.component_registry","title":"component_registry","text":""},{"location":"reference/django_components/component_registry/#django_components.component_registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry: ComponentRegistry = ComponentRegistry()\n</code></pre> <p>Global component registry.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.register","title":"register","text":"<pre><code>register(name: str) -&gt; Callable[[_TC], _TC]\n</code></pre> <p>Class decorator to register a component.</p> Usage <pre><code>    @register(\"my_component\")\n    class MyComponent(component.Component):\n        ...\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(name: str) -&gt; Callable[[_TC], _TC]:\n    \"\"\"Class decorator to register a component.\n\n    Usage:\n        ```python\n            @register(\"my_component\")\n            class MyComponent(component.Component):\n                ...\n        ```\n    \"\"\"\n\n    def decorator(component: _TC) -&gt; _TC:\n        registry.register(name=name, component=component)\n        return component\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/logger/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> logger","text":""},{"location":"reference/django_components/logger/#django_components.logger","title":"logger","text":""},{"location":"reference/django_components/management/","title":"Index","text":""},{"location":"reference/django_components/management/#django_components.management","title":"management","text":""},{"location":"reference/django_components/management/commands/","title":"Index","text":""},{"location":"reference/django_components/management/commands/#django_components.management.commands","title":"commands","text":""},{"location":"reference/django_components/management/commands/startcomponent/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> startcomponent","text":""},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent","title":"startcomponent","text":""},{"location":"reference/django_components/management/commands/upgradecomponent/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> upgradecomponent","text":""},{"location":"reference/django_components/management/commands/upgradecomponent/#django_components.management.commands.upgradecomponent","title":"upgradecomponent","text":""},{"location":"reference/django_components/middleware/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> middleware","text":""},{"location":"reference/django_components/middleware/#django_components.middleware","title":"middleware","text":""},{"location":"reference/django_components/middleware/#django_components.middleware.ComponentDependencyMiddleware","title":"ComponentDependencyMiddleware","text":"<pre><code>ComponentDependencyMiddleware(get_response: Callable[[HttpRequest], HttpResponse])\n</code></pre> <p>Middleware that inserts CSS/JS dependencies for all rendered components at points marked with template tags.</p> Source code in <code>src/django_components/middleware.py</code> <pre><code>def __init__(self, get_response: \"Callable[[HttpRequest], HttpResponse]\") -&gt; None:\n    self.get_response = get_response\n</code></pre>"},{"location":"reference/django_components/middleware/#django_components.middleware.DependencyReplacer","title":"DependencyReplacer","text":"<pre><code>DependencyReplacer(css_string: bytes, js_string: bytes)\n</code></pre> <p>Replacer for use in re.sub that replaces the first placeholder CSS and JS tags it encounters and removes any subsequent ones.</p> Source code in <code>src/django_components/middleware.py</code> <pre><code>def __init__(self, css_string: bytes, js_string: bytes) -&gt; None:\n    self.js_string = js_string\n    self.css_string = css_string\n</code></pre>"},{"location":"reference/django_components/middleware/#django_components.middleware.join_media","title":"join_media","text":"<pre><code>join_media(components: Iterable[Component]) -&gt; Media\n</code></pre> <p>Return combined media object for iterable of components.</p> Source code in <code>src/django_components/middleware.py</code> <pre><code>def join_media(components: Iterable[\"Component\"]) -&gt; Media:\n    \"\"\"Return combined media object for iterable of components.\"\"\"\n\n    return sum([component.media for component in components], Media())\n</code></pre>"},{"location":"reference/django_components/safer_staticfiles/","title":"Index","text":""},{"location":"reference/django_components/safer_staticfiles/#django_components.safer_staticfiles","title":"safer_staticfiles","text":""},{"location":"reference/django_components/safer_staticfiles/#django_components.safer_staticfiles.apps","title":"apps","text":""},{"location":"reference/django_components/safer_staticfiles/#django_components.safer_staticfiles.apps.SaferStaticFilesConfig","title":"SaferStaticFilesConfig","text":"<p>             Bases: <code>StaticFilesConfig</code></p> <p>Extend the <code>ignore_patterns</code> class attr of StaticFilesConfig to include Python modules and HTML files.</p> <p>When this class is registered as an installed app, <code>$ ./manage.py collectstatic</code> will ignore .py and .html files, preventing potentially sensitive backend logic from being leaked by the static file server.</p>"},{"location":"reference/django_components/safer_staticfiles/apps/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> apps","text":""},{"location":"reference/django_components/safer_staticfiles/apps/#django_components.safer_staticfiles.apps","title":"apps","text":""},{"location":"reference/django_components/safer_staticfiles/apps/#django_components.safer_staticfiles.apps.SaferStaticFilesConfig","title":"SaferStaticFilesConfig","text":"<p>             Bases: <code>StaticFilesConfig</code></p> <p>Extend the <code>ignore_patterns</code> class attr of StaticFilesConfig to include Python modules and HTML files.</p> <p>When this class is registered as an installed app, <code>$ ./manage.py collectstatic</code> will ignore .py and .html files, preventing potentially sensitive backend logic from being leaked by the static file server.</p>"},{"location":"reference/django_components/slots/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> slots","text":""},{"location":"reference/django_components/slots/#django_components.slots","title":"slots","text":""},{"location":"reference/django_components/slots/#django_components.slots.ImplicitFillNode","title":"ImplicitFillNode","text":"<pre><code>ImplicitFillNode(nodelist: NodeList)\n</code></pre> <p>             Bases: <code>BaseFillNode</code></p> <p>Instantiated when a <code>component</code> tag pair is passed template content that excludes <code>fill</code> tags. Nodes of this type contribute their nodelists to slots marked as 'default'.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, nodelist: NodeList):\n    self.nodelist: NodeList = nodelist\n</code></pre>"},{"location":"reference/django_components/slots/#django_components.slots.UserSlotVar","title":"UserSlotVar","text":"<pre><code>UserSlotVar(slot: SlotNode, context: Context)\n</code></pre> <p>Extensible mechanism for offering 'fill' blocks in template access to properties of parent slot.</p> <p>How it works: At render time, SlotNode(s) that have been aliased in the fill tag of the component instance create an instance of UserSlotVar. This instance is made available to the rendering context on a key matching the slot alias (see SlotNode.render() for implementation).</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, slot: \"SlotNode\", context: Context):\n    self._slot = slot\n    self._context = context\n</code></pre>"},{"location":"reference/django_components/slots/#django_components.slots.parse_slot_fill_nodes_from_component_nodelist","title":"parse_slot_fill_nodes_from_component_nodelist","text":"<pre><code>parse_slot_fill_nodes_from_component_nodelist(\n    component_nodelist: NodeList, ComponentNodeCls: Type[Node]\n) -&gt; Union[Iterable[NamedFillNode], ImplicitFillNode]\n</code></pre> <p>Given a component body (<code>django.template.NodeList</code>), find all slot fills, whether defined explicitly with <code>{% fill %}</code> or implicitly.</p> <p>So if we have a component body: <pre><code>{% component \"mycomponent\" %}\n    {% fill \"first_fill\" %}\n        Hello!\n    {% endfill %}\n    {% fill \"second_fill\" %}\n        Hello too!\n    {% endfill %}\n{% endcomponent %}\n</code></pre> Then this function returns the nodes (<code>django.template.Node</code>) for <code>fill \"first_fill\"</code> and <code>fill \"second_fill\"</code>.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def parse_slot_fill_nodes_from_component_nodelist(\n    component_nodelist: NodeList,\n    ComponentNodeCls: Type[Node],\n) -&gt; Union[Iterable[NamedFillNode], ImplicitFillNode]:\n    \"\"\"\n    Given a component body (`django.template.NodeList`), find all slot fills,\n    whether defined explicitly with `{% fill %}` or implicitly.\n\n    So if we have a component body:\n    ```django\n    {% component \"mycomponent\" %}\n        {% fill \"first_fill\" %}\n            Hello!\n        {% endfill %}\n        {% fill \"second_fill\" %}\n            Hello too!\n        {% endfill %}\n    {% endcomponent %}\n    ```\n    Then this function returns the nodes (`django.template.Node`) for `fill \"first_fill\"`\n    and `fill \"second_fill\"`.\n    \"\"\"\n    fill_nodes: Union[Iterable[NamedFillNode], ImplicitFillNode] = []\n    if _block_has_content(component_nodelist):\n        for parse_fn in (\n            _try_parse_as_default_fill,\n            _try_parse_as_named_fill_tag_set,\n        ):\n            curr_fill_nodes = parse_fn(component_nodelist, ComponentNodeCls)\n            if curr_fill_nodes:\n                fill_nodes = curr_fill_nodes\n                break\n        else:\n            raise TemplateSyntaxError(\n                \"Illegal content passed to 'component' tag pair. \"\n                \"Possible causes: 1) Explicit 'fill' tags cannot occur alongside other \"\n                \"tags except comment tags; 2) Default (default slot-targeting) content \"\n                \"is mixed with explict 'fill' tags.\"\n            )\n    return fill_nodes\n</code></pre>"},{"location":"reference/django_components/slots/#django_components.slots.render_component_template_with_slots","title":"render_component_template_with_slots","text":"<pre><code>render_component_template_with_slots(\n    template: Template,\n    context: Context,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]],\n    registered_name: Optional[str],\n) -&gt; str\n</code></pre> <p>Given a template, context, and slot fills, this function first prepares the template to be able to render the fills in the place of slots, and then renders the template with given context.</p> <p>NOTE: The template is mutated in the process!</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def render_component_template_with_slots(\n    template: Template,\n    context: Context,\n    fill_content: Union[DefaultFillContent, Iterable[NamedFillContent]],\n    registered_name: Optional[str],\n) -&gt; str:\n    \"\"\"\n    Given a template, context, and slot fills, this function first prepares\n    the template to be able to render the fills in the place of slots, and then\n    renders the template with given context.\n\n    NOTE: The template is mutated in the process!\n    \"\"\"\n    prev_filled_slots_context: Optional[FilledSlotsContext] = context.get(FILLED_SLOTS_CONTENT_CONTEXT_KEY)\n    updated_filled_slots_context = _prepare_component_template_filled_slot_context(\n        template,\n        fill_content,\n        prev_filled_slots_context,\n        registered_name,\n    )\n    with context.update({FILLED_SLOTS_CONTENT_CONTEXT_KEY: updated_filled_slots_context}):\n        return template.render(context)\n</code></pre>"},{"location":"reference/django_components/template_loader/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> template_loader","text":""},{"location":"reference/django_components/template_loader/#django_components.template_loader","title":"template_loader","text":"<p>Template loader that loads templates from each Django app's \"components\" directory.</p>"},{"location":"reference/django_components/templatetags/","title":"Index","text":""},{"location":"reference/django_components/templatetags/#django_components.templatetags","title":"templatetags","text":""},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags","title":"component_tags","text":""},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.check_for_isolated_context_keyword","title":"check_for_isolated_context_keyword","text":"<pre><code>check_for_isolated_context_keyword(bits: List[str]) -&gt; Tuple[List[str], bool]\n</code></pre> <p>Return True and strip the last word if token ends with 'only' keyword or if CONTEXT_BEHAVIOR is 'isolated'.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def check_for_isolated_context_keyword(bits: List[str]) -&gt; Tuple[List[str], bool]:\n    \"\"\"Return True and strip the last word if token ends with 'only' keyword or if CONTEXT_BEHAVIOR is 'isolated'.\"\"\"\n\n    if bits[-1] == \"only\":\n        return bits[:-1], True\n\n    if app_settings.CONTEXT_BEHAVIOR == \"isolated\":\n        return bits, True\n\n    return bits, False\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component_css_dependencies_tag","title":"component_css_dependencies_tag","text":"<pre><code>component_css_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where CSS link tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_css_dependencies\")\ndef component_css_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where CSS link tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + CSS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_css_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component_dependencies_tag","title":"component_dependencies_tag","text":"<pre><code>component_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where CSS link and JS script tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_dependencies\")\ndef component_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where CSS link and JS script tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + CSS_DEPENDENCY_PLACEHOLDER + JS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component_js_dependencies_tag","title":"component_js_dependencies_tag","text":"<pre><code>component_js_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where JS script tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_js_dependencies\")\ndef component_js_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where JS script tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + JS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_js_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.do_component","title":"do_component","text":"<pre><code>do_component(parser: Parser, token: Token) -&gt; ComponentNode\n</code></pre> To give the component access to the template context <p><code>{% component \"name\" positional_arg keyword_arg=value ... %}</code></p> To render the component in an isolated context <p><code>{% component \"name\" positional_arg keyword_arg=value ... only %}</code></p> <p>Positional and keyword arguments can be literals or template variables. The component name must be a single- or double-quotes string and must be either the first positional argument or, if there are no positional arguments, passed as 'name'.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"component\")\ndef do_component(parser: Parser, token: Token) -&gt; ComponentNode:\n    \"\"\"\n    To give the component access to the template context:\n        ```#!htmldjango {% component \"name\" positional_arg keyword_arg=value ... %}```\n\n    To render the component in an isolated context:\n        ```#!htmldjango {% component \"name\" positional_arg keyword_arg=value ... only %}```\n\n    Positional and keyword arguments can be literals or template variables.\n    The component name must be a single- or double-quotes string and must\n    be either the first positional argument or, if there are no positional\n    arguments, passed as 'name'.\n    \"\"\"\n\n    bits = token.split_contents()\n    bits, isolated_context = check_for_isolated_context_keyword(bits)\n    component_name, context_args, context_kwargs = parse_component_with_args(parser, bits, \"component\")\n    body: NodeList = parser.parse(parse_until=[\"endcomponent\"])\n    parser.delete_first_token()\n    fill_nodes = parse_slot_fill_nodes_from_component_nodelist(body, ComponentNode)\n    component_node = ComponentNode(\n        FilterExpression(component_name, parser),\n        context_args,\n        context_kwargs,\n        isolated_context=isolated_context,\n        fill_nodes=fill_nodes,\n    )\n\n    return component_node\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.do_fill","title":"do_fill","text":"<pre><code>do_fill(parser: Parser, token: Token) -&gt; NamedFillNode\n</code></pre> <p>Block tag whose contents 'fill' (are inserted into) an identically named 'slot'-block in the component template referred to by a parent component. It exists to make component nesting easier.</p> <p>This tag is available only within a {% component %}..{% endcomponent %} block. Runtime checks should prohibit other usages.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"fill\")\ndef do_fill(parser: Parser, token: Token) -&gt; NamedFillNode:\n    \"\"\"Block tag whose contents 'fill' (are inserted into) an identically named\n    'slot'-block in the component template referred to by a parent component.\n    It exists to make component nesting easier.\n\n    This tag is available only within a {% component %}..{% endcomponent %} block.\n    Runtime checks should prohibit other usages.\n    \"\"\"\n    bits = token.split_contents()\n    tag = bits[0]\n    args = bits[1:]\n    # e.g. {% fill &lt;name&gt; %}\n    alias_fexp: Optional[FilterExpression] = None\n    if len(args) == 1:\n        tgt_slot_name: str = args[0]\n    # e.g. {% fill &lt;name&gt; as &lt;alias&gt; %}\n    elif len(args) == 3:\n        tgt_slot_name, as_keyword, alias = args\n        if as_keyword.lower() != \"as\":\n            raise TemplateSyntaxError(f\"{tag} tag args do not conform to pattern '&lt;target slot&gt; as &lt;alias&gt;'\")\n        alias_fexp = FilterExpression(alias, parser)\n    else:\n        raise TemplateSyntaxError(f\"'{tag}' tag takes either 1 or 3 arguments: Received {len(args)}.\")\n    nodelist = parser.parse(parse_until=[\"endfill\"])\n    parser.delete_first_token()\n\n    return NamedFillNode(\n        nodelist,\n        name_fexp=FilterExpression(tgt_slot_name, tag),\n        alias_fexp=alias_fexp,\n    )\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.do_if_filled_block","title":"do_if_filled_block","text":"<pre><code>do_if_filled_block(parser: Parser, token: Token) -&gt; IfSlotFilledNode\n</code></pre> Example <pre><code>{% if_filled &lt;slot&gt; (&lt;bool&gt;) %}\n    ...\n{% elif_filled &lt;slot&gt; (&lt;bool&gt;) %}\n    ...\n{% else_filled %}\n    ...\n{% endif_filled %}\n</code></pre> Notes <p>Optional arg <code>&lt;bool&gt;</code> is True by default. If a False is provided instead, the effect is a negation of the <code>if_filled</code> check: The behavior is analogous to <code>if not is_filled &lt;slot&gt;</code>. This design prevents us having to define a separate <code>if_unfilled</code> tag.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"if_filled\")\ndef do_if_filled_block(parser: Parser, token: Token) -&gt; \"IfSlotFilledNode\":\n    \"\"\"\n    Example:\n        ```htmldjango\n        {% if_filled &lt;slot&gt; (&lt;bool&gt;) %}\n            ...\n        {% elif_filled &lt;slot&gt; (&lt;bool&gt;) %}\n            ...\n        {% else_filled %}\n            ...\n        {% endif_filled %}\n        ```\n\n    Notes:\n        Optional arg `&lt;bool&gt;` is True by default.\n        If a False is provided instead, the effect is a negation of the `if_filled` check:\n        The behavior is analogous to `if not is_filled &lt;slot&gt;`.\n        This design prevents us having to define a separate `if_unfilled` tag.\n    \"\"\"\n    bits = token.split_contents()\n    starting_tag = bits[0]\n    slot_name, is_positive = parse_if_filled_bits(bits)\n    nodelist: NodeList = parser.parse((\"elif_filled\", \"else_filled\", \"endif_filled\"))\n    branches: List[_IfSlotFilledBranchNode] = [\n        IfSlotFilledConditionBranchNode(\n            slot_name=slot_name,  # type: ignore\n            nodelist=nodelist,\n            is_positive=is_positive,\n        )\n    ]\n\n    token = parser.next_token()\n\n    # {% elif_filled &lt;slot&gt; (&lt;is_positive&gt;) %} (repeatable)\n    while token.contents.startswith(\"elif_filled\"):\n        bits = token.split_contents()\n        slot_name, is_positive = parse_if_filled_bits(bits)\n        nodelist = parser.parse((\"elif_filled\", \"else_filled\", \"endif_filled\"))\n        branches.append(\n            IfSlotFilledConditionBranchNode(\n                slot_name=slot_name,  # type: ignore\n                nodelist=nodelist,\n                is_positive=is_positive,\n            )\n        )\n\n        token = parser.next_token()\n\n    # {% else_filled %} (optional)\n    if token.contents.startswith(\"else_filled\"):\n        bits = token.split_contents()\n        _, _ = parse_if_filled_bits(bits)\n        nodelist = parser.parse((\"endif_filled\",))\n        branches.append(IfSlotFilledElseBranchNode(nodelist))\n        token = parser.next_token()\n\n    # {% endif_filled %}\n    if token.contents != \"endif_filled\":\n        raise TemplateSyntaxError(\n            f\"{{% {starting_tag} %}} missing closing {{% endif_filled %}} tag\"\n            f\" at line {token.lineno}: '{token.contents}'\"\n        )\n\n    return IfSlotFilledNode(branches)\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.get_components_from_preload_str","title":"get_components_from_preload_str","text":"<pre><code>get_components_from_preload_str(preload_str: str) -&gt; List[Component]\n</code></pre> <p>Returns a list of unique components from a comma-separated str</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def get_components_from_preload_str(preload_str: str) -&gt; List[\"Component\"]:\n    \"\"\"Returns a list of unique components from a comma-separated str\"\"\"\n\n    components = []\n    for component_name in preload_str.split(\",\"):\n        component_name = component_name.strip()\n        if not component_name:\n            continue\n        component_class = component_registry.get(component_name)\n        components.append(component_class(component_name))\n\n    return components\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.get_components_from_registry","title":"get_components_from_registry","text":"<pre><code>get_components_from_registry(registry: ComponentRegistry) -&gt; List[Component]\n</code></pre> <p>Returns a list unique components from the registry.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def get_components_from_registry(registry: ComponentRegistry) -&gt; List[\"Component\"]:\n    \"\"\"Returns a list unique components from the registry.\"\"\"\n\n    unique_component_classes = set(registry.all().values())\n\n    components = []\n    for component_class in unique_component_classes:\n        components.append(component_class(component_class.__name__))\n\n    return components\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> component_tags","text":""},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags","title":"component_tags","text":""},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.check_for_isolated_context_keyword","title":"check_for_isolated_context_keyword","text":"<pre><code>check_for_isolated_context_keyword(bits: List[str]) -&gt; Tuple[List[str], bool]\n</code></pre> <p>Return True and strip the last word if token ends with 'only' keyword or if CONTEXT_BEHAVIOR is 'isolated'.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def check_for_isolated_context_keyword(bits: List[str]) -&gt; Tuple[List[str], bool]:\n    \"\"\"Return True and strip the last word if token ends with 'only' keyword or if CONTEXT_BEHAVIOR is 'isolated'.\"\"\"\n\n    if bits[-1] == \"only\":\n        return bits[:-1], True\n\n    if app_settings.CONTEXT_BEHAVIOR == \"isolated\":\n        return bits, True\n\n    return bits, False\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component_css_dependencies_tag","title":"component_css_dependencies_tag","text":"<pre><code>component_css_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where CSS link tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_css_dependencies\")\ndef component_css_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where CSS link tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + CSS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_css_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component_dependencies_tag","title":"component_dependencies_tag","text":"<pre><code>component_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where CSS link and JS script tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_dependencies\")\ndef component_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where CSS link and JS script tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + CSS_DEPENDENCY_PLACEHOLDER + JS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component_js_dependencies_tag","title":"component_js_dependencies_tag","text":"<pre><code>component_js_dependencies_tag(preload: str = '') -&gt; SafeString\n</code></pre> <p>Marks location where JS script tags should be rendered.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.simple_tag(name=\"component_js_dependencies\")\ndef component_js_dependencies_tag(preload: str = \"\") -&gt; SafeString:\n    \"\"\"Marks location where JS script tags should be rendered.\"\"\"\n\n    if is_dependency_middleware_active():\n        preloaded_dependencies = []\n        for component in get_components_from_preload_str(preload):\n            preloaded_dependencies.append(RENDERED_COMMENT_TEMPLATE.format(name=component.registered_name))\n        return mark_safe(\"\\n\".join(preloaded_dependencies) + JS_DEPENDENCY_PLACEHOLDER)\n    else:\n        rendered_dependencies = []\n        for component in get_components_from_registry(component_registry):\n            rendered_dependencies.append(component.render_js_dependencies())\n\n        return mark_safe(\"\\n\".join(rendered_dependencies))\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.do_component","title":"do_component","text":"<pre><code>do_component(parser: Parser, token: Token) -&gt; ComponentNode\n</code></pre> To give the component access to the template context <p><code>{% component \"name\" positional_arg keyword_arg=value ... %}</code></p> To render the component in an isolated context <p><code>{% component \"name\" positional_arg keyword_arg=value ... only %}</code></p> <p>Positional and keyword arguments can be literals or template variables. The component name must be a single- or double-quotes string and must be either the first positional argument or, if there are no positional arguments, passed as 'name'.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"component\")\ndef do_component(parser: Parser, token: Token) -&gt; ComponentNode:\n    \"\"\"\n    To give the component access to the template context:\n        ```#!htmldjango {% component \"name\" positional_arg keyword_arg=value ... %}```\n\n    To render the component in an isolated context:\n        ```#!htmldjango {% component \"name\" positional_arg keyword_arg=value ... only %}```\n\n    Positional and keyword arguments can be literals or template variables.\n    The component name must be a single- or double-quotes string and must\n    be either the first positional argument or, if there are no positional\n    arguments, passed as 'name'.\n    \"\"\"\n\n    bits = token.split_contents()\n    bits, isolated_context = check_for_isolated_context_keyword(bits)\n    component_name, context_args, context_kwargs = parse_component_with_args(parser, bits, \"component\")\n    body: NodeList = parser.parse(parse_until=[\"endcomponent\"])\n    parser.delete_first_token()\n    fill_nodes = parse_slot_fill_nodes_from_component_nodelist(body, ComponentNode)\n    component_node = ComponentNode(\n        FilterExpression(component_name, parser),\n        context_args,\n        context_kwargs,\n        isolated_context=isolated_context,\n        fill_nodes=fill_nodes,\n    )\n\n    return component_node\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.do_fill","title":"do_fill","text":"<pre><code>do_fill(parser: Parser, token: Token) -&gt; NamedFillNode\n</code></pre> <p>Block tag whose contents 'fill' (are inserted into) an identically named 'slot'-block in the component template referred to by a parent component. It exists to make component nesting easier.</p> <p>This tag is available only within a {% component %}..{% endcomponent %} block. Runtime checks should prohibit other usages.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"fill\")\ndef do_fill(parser: Parser, token: Token) -&gt; NamedFillNode:\n    \"\"\"Block tag whose contents 'fill' (are inserted into) an identically named\n    'slot'-block in the component template referred to by a parent component.\n    It exists to make component nesting easier.\n\n    This tag is available only within a {% component %}..{% endcomponent %} block.\n    Runtime checks should prohibit other usages.\n    \"\"\"\n    bits = token.split_contents()\n    tag = bits[0]\n    args = bits[1:]\n    # e.g. {% fill &lt;name&gt; %}\n    alias_fexp: Optional[FilterExpression] = None\n    if len(args) == 1:\n        tgt_slot_name: str = args[0]\n    # e.g. {% fill &lt;name&gt; as &lt;alias&gt; %}\n    elif len(args) == 3:\n        tgt_slot_name, as_keyword, alias = args\n        if as_keyword.lower() != \"as\":\n            raise TemplateSyntaxError(f\"{tag} tag args do not conform to pattern '&lt;target slot&gt; as &lt;alias&gt;'\")\n        alias_fexp = FilterExpression(alias, parser)\n    else:\n        raise TemplateSyntaxError(f\"'{tag}' tag takes either 1 or 3 arguments: Received {len(args)}.\")\n    nodelist = parser.parse(parse_until=[\"endfill\"])\n    parser.delete_first_token()\n\n    return NamedFillNode(\n        nodelist,\n        name_fexp=FilterExpression(tgt_slot_name, tag),\n        alias_fexp=alias_fexp,\n    )\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.do_if_filled_block","title":"do_if_filled_block","text":"<pre><code>do_if_filled_block(parser: Parser, token: Token) -&gt; IfSlotFilledNode\n</code></pre> Example <pre><code>{% if_filled &lt;slot&gt; (&lt;bool&gt;) %}\n    ...\n{% elif_filled &lt;slot&gt; (&lt;bool&gt;) %}\n    ...\n{% else_filled %}\n    ...\n{% endif_filled %}\n</code></pre> Notes <p>Optional arg <code>&lt;bool&gt;</code> is True by default. If a False is provided instead, the effect is a negation of the <code>if_filled</code> check: The behavior is analogous to <code>if not is_filled &lt;slot&gt;</code>. This design prevents us having to define a separate <code>if_unfilled</code> tag.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"if_filled\")\ndef do_if_filled_block(parser: Parser, token: Token) -&gt; \"IfSlotFilledNode\":\n    \"\"\"\n    Example:\n        ```htmldjango\n        {% if_filled &lt;slot&gt; (&lt;bool&gt;) %}\n            ...\n        {% elif_filled &lt;slot&gt; (&lt;bool&gt;) %}\n            ...\n        {% else_filled %}\n            ...\n        {% endif_filled %}\n        ```\n\n    Notes:\n        Optional arg `&lt;bool&gt;` is True by default.\n        If a False is provided instead, the effect is a negation of the `if_filled` check:\n        The behavior is analogous to `if not is_filled &lt;slot&gt;`.\n        This design prevents us having to define a separate `if_unfilled` tag.\n    \"\"\"\n    bits = token.split_contents()\n    starting_tag = bits[0]\n    slot_name, is_positive = parse_if_filled_bits(bits)\n    nodelist: NodeList = parser.parse((\"elif_filled\", \"else_filled\", \"endif_filled\"))\n    branches: List[_IfSlotFilledBranchNode] = [\n        IfSlotFilledConditionBranchNode(\n            slot_name=slot_name,  # type: ignore\n            nodelist=nodelist,\n            is_positive=is_positive,\n        )\n    ]\n\n    token = parser.next_token()\n\n    # {% elif_filled &lt;slot&gt; (&lt;is_positive&gt;) %} (repeatable)\n    while token.contents.startswith(\"elif_filled\"):\n        bits = token.split_contents()\n        slot_name, is_positive = parse_if_filled_bits(bits)\n        nodelist = parser.parse((\"elif_filled\", \"else_filled\", \"endif_filled\"))\n        branches.append(\n            IfSlotFilledConditionBranchNode(\n                slot_name=slot_name,  # type: ignore\n                nodelist=nodelist,\n                is_positive=is_positive,\n            )\n        )\n\n        token = parser.next_token()\n\n    # {% else_filled %} (optional)\n    if token.contents.startswith(\"else_filled\"):\n        bits = token.split_contents()\n        _, _ = parse_if_filled_bits(bits)\n        nodelist = parser.parse((\"endif_filled\",))\n        branches.append(IfSlotFilledElseBranchNode(nodelist))\n        token = parser.next_token()\n\n    # {% endif_filled %}\n    if token.contents != \"endif_filled\":\n        raise TemplateSyntaxError(\n            f\"{{% {starting_tag} %}} missing closing {{% endif_filled %}} tag\"\n            f\" at line {token.lineno}: '{token.contents}'\"\n        )\n\n    return IfSlotFilledNode(branches)\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.get_components_from_preload_str","title":"get_components_from_preload_str","text":"<pre><code>get_components_from_preload_str(preload_str: str) -&gt; List[Component]\n</code></pre> <p>Returns a list of unique components from a comma-separated str</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def get_components_from_preload_str(preload_str: str) -&gt; List[\"Component\"]:\n    \"\"\"Returns a list of unique components from a comma-separated str\"\"\"\n\n    components = []\n    for component_name in preload_str.split(\",\"):\n        component_name = component_name.strip()\n        if not component_name:\n            continue\n        component_class = component_registry.get(component_name)\n        components.append(component_class(component_name))\n\n    return components\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.get_components_from_registry","title":"get_components_from_registry","text":"<pre><code>get_components_from_registry(registry: ComponentRegistry) -&gt; List[Component]\n</code></pre> <p>Returns a list unique components from the registry.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def get_components_from_registry(registry: ComponentRegistry) -&gt; List[\"Component\"]:\n    \"\"\"Returns a list unique components from the registry.\"\"\"\n\n    unique_component_classes = set(registry.all().values())\n\n    components = []\n    for component_class in unique_component_classes:\n        components.append(component_class(component_class.__name__))\n\n    return components\n</code></pre>"},{"location":"reference/django_components/types/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> types","text":""},{"location":"reference/django_components/types/#django_components.types","title":"types","text":"<p>Helper types for IDEs.</p>"},{"location":"reference/django_components/utils/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utils","text":""},{"location":"reference/django_components/utils/#django_components.utils","title":"utils","text":""},{"location":"reference/django_components/utils/#django_components.utils.search","title":"search","text":"<pre><code>search(search_glob: Optional[str] = None, engine: Optional[Engine] = None) -&gt; Union[List[str], List[Path]]\n</code></pre> <p>Search for directories that may contain components.</p> <p>If <code>search_glob</code> is given, the directories are searched for said glob pattern, and glob search results are returned as a flattened list.</p> Source code in <code>src/django_components/utils.py</code> <pre><code>def search(search_glob: Optional[str] = None, engine: Optional[Engine] = None) -&gt; Union[List[str], List[Path]]:\n    \"\"\"\n    Search for directories that may contain components.\n\n    If `search_glob` is given, the directories are searched for said glob pattern,\n    and glob search results are returned as a flattened list.\n    \"\"\"\n    current_engine = engine\n    if current_engine is None:\n        current_engine = Engine.get_default()\n\n    loader = Loader(current_engine)\n    dirs = loader.get_dirs()\n\n    if search_glob is None:\n        return dirs\n\n    component_filenames: List[str] = []\n    for directory in dirs:\n        for path in glob.iglob(str(Path(directory) / search_glob), recursive=True):\n            component_filenames.append(path)\n\n    return component_filenames\n</code></pre>"},{"location":"user_guide/","title":"Getting started","text":""},{"location":"user_guide/#summary","title":"Summary","text":"<ul> <li>Installation<ul> <li>Compatibility &amp; Requirements</li> </ul> </li> <li>Creating &amp; Using Components<ul> <li>Creating Your First Component</li> <li>Using Components</li> <li>Single File Components</li> <li>Context Scope</li> <li>Using Slots</li> <li>Advanced Component Usage</li> </ul> </li> <li>Integration with your Django project<ul> <li>Security</li> <li>Middleware</li> <li>Settings</li> <li>CLI Commands</li> <li>Logging and Debugging</li> </ul> </li> </ul>"},{"location":"user_guide/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Getting Started</li> <li>Installation<ul> <li>Compatibility &amp; Requirements</li> </ul> </li> <li>Creating &amp; Using Components<ul> <li>Creating Your First Component</li> <li>Using Components</li> <li>Single File Components</li> <li>Context Scope</li> <li>Using Slots</li> <li>Advanced Component Usage</li> </ul> </li> <li>Integration with your Django project<ul> <li>Security</li> <li>Middleware</li> <li>Settings</li> <li>CLI Commands</li> <li>Logging and Debugging</li> </ul> </li> </ul>"},{"location":"user_guide/creating_using_components/advanced/","title":"Advanced","text":""},{"location":"user_guide/creating_using_components/advanced/#re-using-content-defined-in-the-original-slot","title":"Re-using content defined in the original slot","text":"<p>Certain properties of a slot can be accessed from within a 'fill' context. They are provided as attributes on a user-defined alias of the targeted slot. For instance, let's say you're filling a slot called 'body'. To access properties of this slot, alias it using the 'as' keyword to a new name -- or keep the original name. With the new slot alias, you can call <code>&lt;alias&gt;.default</code> to insert the default content.</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"body\" as \"body\" %}{{ body.default }}. Have a great day!{% endfill %}\n{% endcomponent %}\n</code></pre> <p>Produces:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Today's date is &lt;span&gt;2020-06-06&lt;/span&gt;. Have a great day!\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"user_guide/creating_using_components/advanced/#conditional-slots","title":"Conditional slots","text":"<p>Added in version 0.26.</p> <p>In certain circumstances, you may want the behavior of slot filling to depend on whether or not a particular slot is filled.</p> <p>For example, suppose we have the following component template:</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>By default the slot named 'subtitle' is empty. Yet when the component is used without explicit fills, the div containing the slot is still rendered, as shown below:</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        Title\n    &lt;/div&gt;\n    &lt;div class=\"subtitle\"&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>This may not be what you want. What if instead the outer 'subtitle' div should only be included when the inner slot is in fact filled?</p> <p>The answer is to use the <code>{% if_filled &lt;name&gt; %}</code> tag. Together with <code>{% endif_filled %}</code>, these define a block whose contents will be rendered only if the component slot with the corresponding 'name' is filled.</p> <p>This is what our example looks like with an 'if_filled' tag.</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    {% if_filled \"subtitle\" %}\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n    {% endif_filled %}\n&lt;/div&gt;\n</code></pre> <p>Just as Django's builtin 'if' tag has 'elif' and 'else' counterparts, so does 'if_filled' include additional tags for more complex branching. These tags are 'elif_filled' and 'else_filled'. Here's what our example looks like with them.</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    {% if_filled \"subtitle\" %}\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n    {% elif_filled \"title\" %}\n        ...\n    {% else_filled %}\n        ...\n    {% endif_filled %}\n&lt;/div&gt;\n</code></pre> <p>Sometimes you're not interested in whether a slot is filled, but rather that it isn't. To negate the meaning of 'if_filled' in this way, an optional boolean can be passed to the 'if_filled' and 'elif_filled' tags.</p> <p>In the example below we use <code>False</code> to indicate that the content should be rendered only if the slot 'subtitle' is not filled.</p> <pre><code>{% if_filled subtitle False %}\n&lt;div class=\"subtitle\"&gt;\n    {% slot \"subtitle\" %}{% endslot %}\n&lt;/div&gt;\n{% endif_filled %}\n</code></pre>"},{"location":"user_guide/creating_using_components/context_scope/","title":"Component context and scope","text":"<p>By default, components can access context variables from the parent template, just like templates that are included with the <code>{% include %}</code> tag. Just like with <code>{% include %}</code>, if you don't want the component template to have access to the parent context, add <code>only</code> to the end of the <code>{% component %}</code> tag):</p> <pre><code>   {% component \"calendar\" date=\"2015-06-19\" only %}{% endcomponent %}\n</code></pre> <p>NOTE: <code>{% csrf_token %}</code> tags need access to the top-level context, and they will not function properly if they are rendered in a component that is called with the <code>only</code> modifier.</p> <p>Components can also access the outer context in their context methods by accessing the property <code>outer_context</code>.</p> <p>You can also set <code>context_behavior</code> to <code>isolated</code> to make all components isolated by default. This is useful if you want to make sure that components don't accidentally access the outer context.</p>"},{"location":"user_guide/creating_using_components/create_first_component/","title":"Create your first component","text":"<p>A component in django-components is the combination of four things: CSS, Javascript, a Django template, and some Python code to put them all together.</p> <p></p> <p>Start by creating empty files in the structure above.</p> <p>First you need a CSS file. Be sure to prefix all rules with a unique class so they don't clash with other rules.</p> [project root]/components/calendar/style.css<pre><code>.calendar-component { width: 200px; background: pink; }\n.calendar-component span { font-weight: bold; }\n</code></pre> <p>Then you need a javascript file that specifies how you interact with this component. You are free to use any javascript framework you want. A good way to make sure this component doesn't clash with other components is to define all code inside an anonymous function that calls itself. This makes all variables defined only be defined inside this component and not affect other components.</p> [project root]/components/calendar/script.js<pre><code>(function(){\n    if (document.querySelector(\".calendar-component\")) {\n        document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n    }\n})()\n</code></pre> <p>Now you need a Django template for your component. Feel free to define more variables like <code>date</code> in this example. When creating an instance of this component we will send in the values for these variables. The template will be rendered with whatever template backend you've specified in your Django settings file.</p> [project root]/components/calendar/calendar.html<pre><code>&lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;&lt;/div&gt;\n</code></pre> <p>Finally, we use django-components to tie this together. Start by creating a file called <code>calendar.py</code> in your component calendar directory. It will be auto-detected and loaded by the app.</p> <p>Inside this file we create a Component by inheriting from the Component class and specifying the context method. We also register the global component registry so that we easily can render it anywhere in our templates.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import component\n\n@component.register(\"calendar\")\nclass Calendar(component.Component):\n    # Templates inside `[your apps]/components` dir and `[project root]/components` dir will be automatically found. To customize which template to use based on context\n    # you can override def get_template_name() instead of specifying the below variable.\n    template_name = \"calendar.html\"\n\n    # This component takes one parameter, a date string to show in the template\n    def get_context_data(self, date):\n        return {\n            \"date\": date,\n        }\n\n    class Media:\n        css = \"style.css\"\n        js = \"script.js\"\n</code></pre> <p>And voil\u00e0!! We've created our first component.</p>"},{"location":"user_guide/creating_using_components/single_file_component/","title":"Using single-file components","text":"<p>Components can also be defined in a single file, which is useful for small components. To do this, you can use the <code>template</code>, <code>js</code>, and <code>css</code> class attributes instead of the <code>template_name</code> and <code>Media</code>. For example, here's the calendar component from above, defined in a single file:</p> [project root]/components/calendar.py<pre><code>from django_components import component\nfrom django_components import types as t\n\n@component.register(\"calendar\")\nclass Calendar(component.Component):\n    def get_context_data(self, date):\n        return {\n            \"date\": date,\n        }\n\n    template: t.django_html = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;&lt;/div&gt;\n    \"\"\"\n\n    css: t.css = \"\"\"\n        .calendar-component { width: 200px; background: pink; }\n        .calendar-component span { font-weight: bold; }\n    \"\"\"\n\n    js: t.js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar-component\")) {\n                document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n            }\n        })()\n    \"\"\"\n</code></pre> <p>This makes it easy to create small components without having to create a separate template, CSS, and JS file.</p> <p>Note that the <code>t.django_html</code>, <code>t.css</code>, and <code>t.js</code> types are used to specify the type of the template, CSS, and JS files, respectively. This is not necessary, but if you're using VSCode with the Python Inline Source Syntax Highlighting extension, it will give you syntax highlighting for the template, CSS, and JS.</p>"},{"location":"user_guide/creating_using_components/use_component/","title":"Use the component in a template","text":"<p>First load the <code>component_tags</code> tag library, then use the <code>component_[js/css]_dependencies</code> and <code>component</code> tags to render the component to the page.</p> <pre><code>{% load component_tags %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n    {% component_css_dependencies %}\n&lt;/head&gt;\n&lt;body&gt;\n    {% component \"calendar\" date=\"2015-06-19\" %}{% endcomponent %}\n    {% component_js_dependencies %}\n&lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>The output from the above template will be:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n    &lt;link href=\"style.css\" type=\"text/css\" media=\"all\" rel=\"stylesheet\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;2015-06-19&lt;/span&gt;&lt;/div&gt;\n    &lt;script src=\"script.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>This makes it possible to organize your front-end around reusable components. Instead of relying on template tags and keeping your CSS and Javascript in the static directory.</p>"},{"location":"user_guide/creating_using_components/using_slots/","title":"Using slots in templates","text":"<p>New in version 0.26:</p> <ul> <li>The <code>slot</code> tag now serves only to declare new slots inside the component template.<ul> <li>To override the content of a declared slot, use the newly introduced <code>fill</code> tag instead.</li> </ul> </li> <li>Whereas unfilled slots used to raise a warning, filling a slot is now optional by default.<ul> <li>To indicate that a slot must be filled, the new <code>required</code> option should be added at the end of the <code>slot</code> tag.</li> </ul> </li> </ul> <p>Components support something called 'slots'. When a component is used inside another template, slots allow the parent template to override specific parts of the child component by passing in different content. This mechanism makes components more reusable and composable.</p> <p>In the example below we introduce two block tags that work hand in hand to make this work. These are...</p> <ul> <li><code>{% slot &lt;name&gt; %}</code>/<code>{% endslot %}</code>: Declares a new slot in the component template.</li> <li><code>{% fill &lt;name&gt; %}</code>/<code>{% endfill %}</code>: (Used inside a <code>component</code> tag pair.) Fills a declared slot with the specified content.</li> </ul> <p>Let's update our calendar component to support more customization. We'll add <code>slot</code> tag pairs to its template, calendar.html.</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"header\" %}Calendar header{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"body\" %}Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>When using the component, you specify which slots you want to fill and where you want to use the defaults from the template. It looks like this:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"body\" %}Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??{% endfill %}\n{% endcomponent %}\n</code></pre> <p>Since the header block is unspecified, it's taken from the base template. If you put this in a template, and pass in <code>date=2020-06-06</code>, this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Can you believe it's already &lt;span&gt;2020-06-06&lt;/span&gt;??\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>As you can see, component slots lets you write reusable containers that you fill in when you use a component. This makes for highly reusable components that can be used in different circumstances.</p> <p>It can become tedious to use <code>fill</code> tags everywhere, especially when you're using a component that declares only one slot. To make things easier, <code>slot</code> tags can be marked with an optional keyword: <code>default</code>. When added to the end of the tag (as shown below), this option lets you pass filling content directly in the body of a <code>component</code> tag pair \u2013 without using a <code>fill</code> tag. Choose carefully, though: a component template may contain at most one slot that is marked as <code>default</code>. The <code>default</code> option can be combined with other slot options, e.g. <code>required</code>.</p> <p>Here's the same example as before, except with default slots and implicit filling.</p> <p>The template:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"header\" %}Calendar header{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"body\" default %}Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Including the component (notice how the <code>fill</code> tag is omitted):</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n{% endcomponent %}\n</code></pre> <p>The rendered result (exactly the same as before):</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Can you believe it's already &lt;span&gt;2020-06-06&lt;/span&gt;??\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>You may be tempted to combine implicit fills with explicit <code>fill</code> tags. This will not work. The following component template will raise an error when compiled.</p> <pre><code>{# DON'T DO THIS #}\n{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}Totally new header!{% endfill %}\n    Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n{% endcomponent %}\n</code></pre> <p>By contrast, it is permitted to use <code>fill</code> tags in nested components, e.g.:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% component \"beautiful-box\" %}\n        {% fill \"content\" %} Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;?? {% endfill %}\n    {% endcomponent %}\n{% endcomponent %}\n</code></pre> <p>This is fine too:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}\n        {% component \"calendar-header\" %}\n            Super Special Calendar Header\n        {% endcomponent %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"user_guide/creating_using_components/using_slots/#components-as-views","title":"Components as views","text":"<p>New in version 0.34</p> <p>Components can now be used as views. To do this, <code>Component</code> subclasses Django's <code>View</code> class. This means that you can use all of the methods of <code>View</code> in your component. For example, you can override <code>get</code> and <code>post</code> to handle GET and POST requests, respectively.</p> <p>In addition, <code>Component</code> now has a <code>render_to_response</code> method that renders the component template based on the provided context and slots' data and returns an <code>HttpResponse</code> object.</p> <p>Here's an example of a calendar component defined as a view:</p> [project root]/components/calendar.py<pre><code>from django_components import component\n\n@component.register(\"calendar\")\nclass Calendar(component.Component):\n\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            &lt;div class=\"header\"&gt;\n                {% slot \"header\" %}{% endslot %}\n            &lt;/div&gt;\n            &lt;div class=\"body\"&gt;\n                Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get(self, request, *args, **kwargs):\n        context = {\n            \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n        }\n        slots = {\n            \"header\": \"Calendar header\",\n        }\n        return self.render_to_response(context, slots)\n</code></pre> <p>Then, to use this component as a view, you should create a <code>urls.py</code> file in your components directory, and add a path to the component's view:</p> [project root]/components/urls.py<pre><code>from django.urls import path\nfrom calendar import Calendar\n\nurlpatterns = [\n    path(\"calendar/\", Calendar.as_view()),\n]\n</code></pre> <p>Remember to add <code>__init__.py</code> to your components directory, so that Django can find the <code>urls.py</code> file.</p> <p>Finally, include the component's urls in your project's <code>urls.py</code> file:</p> [project root]/urls.py<pre><code>from django.urls import include, path\n\nurlpatterns = [\n    path(\"components/\", include(\"components.urls\")),\n]\n</code></pre> <p>Note: slots content are automatically escaped by default to prevent XSS attacks. To disable escaping, set <code>escape_slots_content=False</code> in the <code>render_to_response</code> method. If you do so, you should make sure that any content you pass to the slots is safe, especially if it comes from user input.</p> <p>If you're planning on passing an HTML string, check Django's use of <code>format_html</code> and <code>mark_safe</code>.</p>"},{"location":"user_guide/installation/","title":"Installation","text":"<p>Install the app into your environment:</p> pippoetrypdm <pre><code>pip install django-components\n</code></pre> <pre><code>poetry add django-components\n</code></pre> <pre><code>pdm add django-components\n</code></pre> <p>Then add the app into <code>INSTALLED_APPS</code> in your settings module (e.g. <code>settings.py</code>)</p> <pre><code>INSTALLED_APPS = [\n    ...,\n    'django_components',\n]\n</code></pre> <p>Modify <code>TEMPLATES</code> section of your settings module as follows:</p> <ul> <li>Remove <code>'APP_DIRS': True,</code></li> <li>add <code>loaders</code> to <code>OPTIONS</code> list and set it to following value:</li> </ul> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'context_processors': [\n                ...\n            ],\n            'loaders':[(\n                'django.template.loaders.cached.Loader', [\n                    'django.template.loaders.filesystem.Loader',\n                    'django.template.loaders.app_directories.Loader',\n                    'django_components.template_loader.Loader',\n                ]\n            )],\n        },\n    },\n]\n</code></pre> <p>Modify <code>STATICFILES_DIRS</code> (or add it if you don't have it) so django can find your static JS and CSS files:</p> <pre><code>STATICFILES_DIRS = [\n    ...,\n    os.path.join(BASE_DIR, \"components\"),\n]\n</code></pre>"},{"location":"user_guide/installation/#optional-load-django-components-in-all-templates","title":"Optional: Load django-components in all templates","text":"<p>To avoid loading the app in each template using <code>{% load django_components %}</code>, you can add the tag as a 'builtin' in settings.py</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'context_processors': [\n                ...\n            ],\n            'builtins': [\n                'django_components.templatetags.component_tags',\n            ]\n        },\n    },\n]\n</code></pre> <p>Read on to find out how to build your first component!</p>"},{"location":"user_guide/installation/requirements_compatibility/","title":"Compatibility and requirements","text":"<p>Django-components supports all supported combinations versions of Django and Python.</p> Python version Django version 3.8 3.2, 4.0, 4.1, 4.2 3.9 3.2, 4.0, 4.1, 4.2 3.10 3.2, 4.0, 4.1, 4.2, 5.0 3.11 4.1, 4.2, 5.0 3.12 4.2, 5.0 <p>For each version of Django and Python, we recommend using the latest micro release (A.B.C).</p>"},{"location":"user_guide/integration/commands/","title":"Management Command","text":"<p>You can use the built-in management command <code>startcomponent</code> to create a django component. The command accepts the following arguments and options:</p> <ul> <li><code>name</code>: The name of the component to create. This is a required argument.</li> </ul> <ul> <li><code>--path</code>: The path to the components directory. This is an optional argument. If not provided, the command will use the <code>BASE_DIR</code> setting from your Django settings.</li> </ul> <ul> <li><code>--js</code>: The name of the JavaScript file. This is an optional argument. The default value is <code>script.js</code>.</li> </ul> <ul> <li><code>--css</code>: The name of the CSS file. This is an optional argument. The default value is <code>style.css</code>.</li> </ul> <ul> <li><code>--template</code>: The name of the template file. This is an optional argument. The default value is <code>template.html</code>.</li> </ul> <ul> <li><code>--force</code>: This option allows you to overwrite existing files if they exist. This is an optional argument.</li> </ul> <ul> <li><code>--verbose</code>: This option allows the command to print additional information during component creation. This is an optional argument.</li> </ul> <ul> <li><code>--dry-run</code>: This option allows you to simulate component creation without actually creating any files. This is an optional argument. The default value is <code>False</code>.</li> </ul>"},{"location":"user_guide/integration/commands/#management-command-usage","title":"Management Command Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py startcomponent &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"user_guide/integration/commands/#management-command-examples","title":"Management Command Examples","text":"<p>Here are some examples of how you can use the command:</p>"},{"location":"user_guide/integration/commands/#creating-a-component-with-default-settings","title":"Creating a Component with Default Settings","text":"<p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py startcomponent my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p>"},{"location":"user_guide/integration/commands/#creating-a-component-with-custom-settings","title":"Creating a Component with Custom Settings","text":"<p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py startcomponent new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p>"},{"location":"user_guide/integration/commands/#overwriting-an-existing-component","title":"Overwriting an Existing Component","text":"<p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py startcomponent my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p>"},{"location":"user_guide/integration/commands/#simulating-component-creation","title":"Simulating Component Creation","text":"<p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py startcomponent my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"user_guide/integration/logging_debugging/","title":"Logging and debugging","text":"<p>Django components supports logging with Django. This can help with troubleshooting.</p> <p>To configure logging for Django components, set the <code>django_components</code> logger in <code>LOGGING</code> in <code>settings.py</code> (below).</p> <p>Also see the <code>settings.py</code> file in sampleproject for a real-life example.</p> <pre><code>import logging\nimport sys\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    \"handlers\": {\n        \"console\": {\n            'class': 'logging.StreamHandler',\n            'stream': sys.stdout,\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": logging.DEBUG,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre>"},{"location":"user_guide/integration/middleware/","title":"Setting Up <code>ComponentDependencyMiddleware</code>","text":"<p><code>ComponentDependencyMiddleware</code> is a Django middleware designed to manage and inject CSS/JS dependencies for rendered components dynamically. It ensures that only the necessary stylesheets and scripts are loaded in your HTML responses, based on the components used in your Django templates.</p> <p>To set it up, add the middleware to your <code>MIDDLEWARE</code> in settings.py:</p> <pre><code>MIDDLEWARE = [\n    # ... other middleware classes ...\n    'django_components.middleware.ComponentDependencyMiddleware'\n    # ... other middleware classes ...\n]\n</code></pre> <p>Then, enable <code>RENDER_DEPENDENCIES</code> in setting.py:</p> <pre><code>COMPONENTS = {\n    \"RENDER_DEPENDENCIES\": True,\n    # ... other component settings ...\n}\n</code></pre>"},{"location":"user_guide/integration/security/","title":"Security notes \ud83d\udea8","text":"<p>You are advised to read this section before using django-components in production.</p>"},{"location":"user_guide/integration/security/#static-files","title":"Static files","text":"<p>Components can be organized however you prefer. That said, our prefered way is to keep the files of a component close together by bundling them in the same directory. This means that files containing backend logic, such as Python modules and HTML templates, live in the same directory as static files, e.g. JS and CSS.</p> <p>If your are using <code>django.contrib.staticfiles</code> to collect static files, no distinction is made between the different kinds of files. As a result, your Python code and templates may inadvertently become available on your static file server. You probably don't want this, as parts of your backend logic will be exposed, posing a potential security vulnerability.</p> <p>As of v0.27, django-components ships with an additional installable app <code>django_components.safer_staticfiles</code>. It is a drop-in replacement for <code>django.contrib.staticfiles</code>. Its behavior is 100% identical except it ignores .py and .html files, meaning these will not end up on your static files server. To use it, add it to <code>INSTALLED_APPS</code> and remove <code>django.contrib.staticfiles</code>.</p> <pre><code>INSTALLED_APPS = [\n    # 'django.contrib.staticfiles',   # &lt;-- REMOVE\n    'django_components',\n    'django_components.safer_staticfiles'  # &lt;-- ADD\n]\n</code></pre> <p>If you are on an older version of django-components, your alternatives are a) passing <code>--ignore &lt;pattern&gt;</code> options to the collecstatic CLI command, or b) defining a subclass of <code>StaticFilesConfig</code>. Both routes are described in the official docs of the staticfiles app.</p>"},{"location":"user_guide/integration/settings/","title":"Available settings","text":"<p>All library settings are handled from a global <code>COMPONENTS</code> variable that is read from settings.py. By default you don't need it set, there are reasonable defaults.</p>"},{"location":"user_guide/integration/settings/#configure-the-module-where-components-are-loaded-from","title":"Configure the module where components are loaded from","text":"<p>Configure the location where components are loaded. To do this, add a <code>COMPONENTS</code> variable to you settings.py with a list of python paths to load. This allows you to build a structure of components that are independent from your apps.</p> <pre><code>COMPONENTS = {\n    \"libraries\": [\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n}\n</code></pre>"},{"location":"user_guide/integration/settings/#disable-autodiscovery","title":"Disable autodiscovery","text":"<p>If you specify all the component locations with the setting above and have a lot of apps, you can (very) slightly speed things up by disabling autodiscovery.</p> <pre><code>COMPONENTS = {\n    \"autodiscover\": False,\n}\n</code></pre>"},{"location":"user_guide/integration/settings/#tune-the-template-cache","title":"Tune the template cache","text":"<p>Each time a template is rendered it is cached to a global in-memory cache (using Python's lru_cache decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up. By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are using the <code>template</code> method of a component to render lots of dynamic templates, you can increase this number. To remove the cache limit altogether and cache everything, set template_cache_size to <code>None</code>.</p> <pre><code>COMPONENTS = {\n    \"template_cache_size\": 256,\n}\n</code></pre>"},{"location":"user_guide/integration/settings/#isolate-components-context-by-default","title":"Isolate components' context by default","text":"<p>If you'd like to prevent components from accessing the outer context by default, you can set the <code>context_behavior</code> setting to <code>isolated</code>. This is useful if you want to make sure that components don't accidentally access the outer context.</p> <pre><code>COMPONENTS = {\n    \"context_behavior\": \"isolated\",\n}\n</code></pre>"},{"location":"user_guide/integration/settings/#middleware","title":"Middleware","text":"<p>RENDER_DEPENDENCIES: If you are using the <code>ComponentDependencyMiddleware</code> middleware, you can enable or disable it here.</p> <pre><code>COMPONENTS = {\n    \"RENDER_DEPENDENCIES\": True,\n}\n</code></pre>"}]}